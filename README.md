# About the Challenge:

#### Welcome to the Data Structures and Algorithms Coding Interview Bootcamp with Python!

The primary goal of this challenge is to prepare myself for coding interviews at top tech companies. By tackling one problem at a time and understanding its solution, I'll accumulate a variety of tools and techniques for conquering any coding interview.

## Daily Data Structures and Algorithms Coding Challenges:

The course is structured around daily coding challenges. Consistent practice will equip me with the skills required to ace coding interviews. For the next 40 days I'll commit myself to practice atleast 2 coding interview questions everyday. 

## Topics Covered:

We start from the basics with Big O analysis, then move on to very important algorithmic techniques such as Recursion, Backtracking and Dynamic Programming Patterns. After this we move to cover common data structures, and discuss real problems asked in interviews at tech giants such as Google, Meta, Amazon, Netflix, Apple, and Microsoft.


## Challenge Outline:

- Day 1: Arrays, Big O, Sorted Squared Array, Monotonic Array

- Day 2:Recursion,k-th symbol in Grammar,Josephus problem

- Day 3:Recursion, Tower of Hanoi, Power Sum

- Day 4:Backtracking, Permutations, Permutations 2

- Day 5:Backtracking, Subsets, Subsets 2

- Day 6:Backtracking, Combinations, Combinations Sum 1

- Day 7:Backtracking,Combinations Sum 2,Combinations Sum 3

- Day 8:Backtracking,Sudoku Solver, N Queens

- Day 9:Dynamic Programming, Fibonacci, Climbing Stairs

- Day 10:Dynamic Programming, Min Cost Climbing Stairs, Tribonacci

- Day 11:Dynamic Programming, 01 Knapsack, Unbounded Knapsack

- Day 12:Dynamic Programming, Target Sum, Partition Equal Subset Sum

- Day 13:Dynamic Programming, LCS, Edit Distance

- Day 14:Dynamic Programming, LIS, Max Length of Pair Chain, Russian Doll Envelopes

- Day 15:Dynamic Programming, Palindromic Substrings, Longest Palindromic Substring, Longest Palindromic Subsequence

- Day 16:Dynamic Programming, Palindrome Partitioning, Palindrome Partitioning 2

- Day 17:Dynamic Programming, Word Break, Matrix Chain Multiplication

- Day 18:Dynamic Programming, Kadane's algorithm - Max Subarray, Maximum Product Subarray

- Day 19:Greedy Algorithms - Fractional Knpasack, Non overlapping Intervals

- Day 20:Greedy Algorithms - Jump Game 1, Minimum # of arrows to burst baloons

- Day 21:Greedy Algorithms - Two City Scheduling, Boats to Save people

- Day 22:Greedy Algorithms - Task Scheduler, Largest Number

- Day 23:Greedy Algorithms - Gas Stations,  Jump Game 2

- Day 24: Arrays, Rotate Array, Container with Most Water

- Day 25: Hash Tables, Two Sum, Isomorphic Strings

- Day 26: Strings, Non-Repeating Character, Palindrome

- Day 27: Strings, Longest Unique Substring, Group Anagrams

- Day 28: Searching, Binary Search, Search in Rotated Sorted Array

- Day 29: Searching, Find First and Last Position, Search in 2D Array

- Day 30: Sorting, Bubble Sort, Insertion Sort

- Day 31: Sorting, Selection Sort, Merge Sort

- Day 32: Sorting, Quick Sort, Radix Sort

- Day 33: Singly Linked Lists, Construct SLL, Delete Duplicates

- Day 34: Singly Linked Lists, Reverse SLL, Cycle Detection

- Day 35: Singly Linked Lists, Find Duplicate, Add 2 Numbers

- Day 36: Doubly Linked Lists, DLL Remove Insert, DLL Remove All

- Day 37: Stacks, Construct Stack, Reverse Polish Notation

- Day 38: Queues, Construct Queue, Implement Queue with Stack

- Day 39: Binary Trees, Construct BST, Traversal Techniques

- Day 40: Pre order and In order Traversal of Binary Tree - Iterative

- Day 41: Post Order Traversal Iterative, Path Sum 2

- Day 42: Construct Binary Tree from Pre and In order Traversal ^ In and Post order Traversal

- Day 43: Binary Trees, Level Order Traversal, Left/Right View

- Day 44: Level order Trav 2, ZigZag Traversal

- Day 45: Vertical order Traversal, Sum root to leaf numbers

- Day 46: Binary Trees, Invert Tree, Diameter of Tree

- Day 47: Binary Trees, Convert Sorted Array to BST, Validate BST

- Day 48: Lowest common Ancestor of BST, Unique BST 2

- Day 49: Lowest common Ancestor of Binary Tree, Unique BST 1

- Day 50: Serialize and Deserialize Binary Tree, N-ary Tree Level Order Traversal

- Day 51: Heaps, Max Heap, Min Priority Queue

- Day 52: Graphs, BFS, DFS

- Day 53: Graphs, Number of Connected Components, Topological Sort

- Day 54: Number of Provinces, Find if path exists in Graph

- Day 55: Number of Islands, Numbers with same consecutive differences

## All the best for this challenge !!
